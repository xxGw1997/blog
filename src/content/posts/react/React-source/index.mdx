---
title: "1.Build my react - React的整体架构"
date: 2024-10-25
desc: React 的整体架构
---

# React 整体架构

React 15 及以前的架构是 Stack 架构，在 React 16 开始， React 重构了整体的架构，新的架构称之为 Fiber 架构。

> Stack 架构在进行虚拟 Dom 树比较的时候，使用的递归，一旦开始就不能够中断停止，从头进行递归到结束，在 Dom 结构比较复杂时，会消耗较多的时间，在页面上的体现就是会造成页面的卡顿。 而新的 Fiber 架构采用的是链表，在遍历时，可以随时进行中断遍历，并且下次继续从上次中断的位置继续进行任务，实现时间切片，防止 JS 的计算占用过多时，及时将主线程的控制权交还浏览器，等到下一个事件循环时，再继续进行渲染，从而解决了浏览器卡顿，丢帧的情况。

## 旧架构的问题

> React 是用 Javascript 构建快速响应的大型 Web 应用程序的首选方式

无法及时响应的场景

- 执行大量计算或设备性能瓶颈时，页面会出现卡顿、掉帧的情况。这类情况本质是由于 CPU 的瓶颈不足。
- 进行 I/O 操作时，需要等待数据才能进行接下来的操作。这类情况本质是 I/O 的瓶颈限制。

### CPU 瓶颈

浏览器中呈现网页时，浏览器会不断进行的进行绘制页面。目前大部分的设备刷新频率为 60FPS，相当于 1 秒钟的时间，浏览器需要绘制 60 次画面。我们所看到的动画效果也是由一张张绘制的页面连续播放而得到的。
在一个 60FPS 刷新率的设备，浏览器平均会有 16.66ms 来进行一帧页面的绘制。然而浏览器执行 js 的线程与渲染流水线是共用的同一个线程。所以在进行复杂的 js 耗时计算时，会导致渲染一帧的时间超过 16.66ms，从而导致页面看起来卡顿、掉帧。

在 React 中，每次渲染时，都会重新计算整个虚拟 Dom 树，这是一个比较耗时的计算。如果虚拟 Dom 树比较大、比较复杂就会造成计算虚拟 Dom 的时间过长。从而导致动画、以及用户输入等实时更新的操作无法得到及时的响应，从而造成卡顿的现象。

### I/O 瓶颈

对应 web 页面来说，最主要的 I/O 瓶颈就是由于进行网络通信时导致的网络延迟，网络延迟是一种客观存在的现象。
React 开发团队 为了减少这种现象对用户的影响，React 开发团队对操作划分了不同的优先级。

- 为不同操作造成的“自变量变化”赋予不同的优先级
- 所有的优先级进行统一调度，优先处理“最高优先级的更新”（用户交互操作，输入框输入，点击事件等需要立即更新）
- 如果更新正在进行，此时有“更高优先级的更新”产生时，中断当前更新，优先处理高优先级的更新。

而为了满足以上的 3 点要求。React 开发团队需要实现：

- 用于调度优先级的调度器
- 调度器对应的调度算法
- 支持可中断的计算虚拟 DOM 的数据结构

## 新架构 Fiber 的解决思路

> 从 React V16 开始， React 开发团队 引入了 Fiber 的概念，这是一种通过链表来描述虚拟 DOM 的方式。我们通过编写 JSX 来描述 HTML DOM 的结构，而 React 内部会将我们编写的 JSX 代码解析成 Fiber 的内部对象来存放组件树的附加信息。

### 解决 CPU 瓶颈

Fiber 本质上也是一个对象，但是和 React 元素不同的地方在于对象之间会使用链表的数据结构来进行串联起来，child 指向子元素，sibling 指向兄弟元素，return 指向父元素。

<img src="./React-source/fiber.png" alt="image" />

使用链表结构，有一个最大的优势就是在进行树的对比（reconcile）计算时，这个过程时可以被中断的。
当一帧的时间内，无法完成计算时，就需要将操作 js 的主线程的控制权交还给浏览器，让浏览器优先进行渲染，等到下一帧的空余时间再继续进行比对计算。

### 解决 I/O 瓶颈

从 React 16 开始引入了 Scheduler（调度器）, 用来调度任务的优先级。

React 16 之前：

- Reconciler（协调器）: vdom 的实现，根据自变量的变化计算出 UI 的变化。
- Renderer（渲染器）: 将 UI 的变化渲染到宿主环境。

React 16 之后：

- Scheduler（调度器）： 调度任务的优先级，更高优先级的任务会先被调度到 Reconciler。
- Reconciler（协调器）: vdom 的实现，根据自变量的变化计算出 UI 的变化。
- Renderer（渲染器）: 将 UI 的变化渲染到宿主环境。

新架构中 Reconciler 的更新流程从之前的 Stack 递归，变成了可中断的 Fiber 遍历。
